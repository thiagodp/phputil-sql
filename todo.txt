// OK: alias para colunas (AS), ex: lev AS level
// OK: alias para valores (AS), ex: 1 AS level
// OK: IS NULL
// OK: IS NOT NULL
// OK: aggregation functions with distinct, ex. COUNT(DISTINCT order_id)
// OK: names with ` (optional?)
// OK: limit and offset that works according to the database type
// OK: common functions, like COALESCE
// OK: string functions
// OK: date functions

// DB::$type = DBType::MYSQL;
// DB::$type = DBType::POSTGRESQL;
// DB::$type = DBType::SQLSERVER;

ðŸ†—- remove function alias (for not to be used in from())

ðŸ†—- add apostrophe automatically to string values
ðŸ†—- detect DateTime values and represent them as a database strings
ðŸ†—- detect bool values and represent them as TRUE and FALSE
ðŸ†—- detect null values and represent them as NULL

ðŸ†—- add conversion to different databases without using DB or global
ðŸ†—- make alias() a method of a function.
ðŸ†—- rename alias() method to as().
ðŸ†—- add as() method to Column, e.g.: col( 'long' )->as( 'l' )

----
use DB::$type internally

CanLimit
__asName
__toValue

-> keep the API as is ?

Functions can be made available with a constant or a class with static methods.
    e.g.:
    $sql = DB::useMySQL();
    $sql->select( $sql->max( 'total' ) )->from( 'sale' );

Better yet (ðŸ¤”?): let the db be defined in the last method. Internal objects represent each term:
    e.g:
    select( max( 'total' ) )->from( 'sale' )->end( DB::MYSQL ); // ðŸ¤”

    It can be this way, but globally defined with DB::useXXX(). ðŸ‘

    > functions such as max() need to be represented as an object that will receive the database type when
        end() or toString() are executed.

        select( int|float|bool|string|Value|Function )

            Aggregation and other functions are objects of the type Function.
            Class Function can have an attribute $dbType.